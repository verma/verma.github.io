<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Firebase with Clojure & core.async | Uday Verma's Blog</title><meta name=keywords content><meta name=description content="A walkthrough of adding a library function to pani using core.async and multi-methods."><meta name=author content><link rel=canonical href=http://udayv.com/blog/2014-09-03-firebase-with-clojure-and-coreasync/><link href=/assets/css/stylesheet.min.3dac925eb9bf5bf78d5d4e966755e4f4ae8ca86c5a9a3d1dcff2aaef78333302.css integrity="sha256-PaySXrm/W/eNXU6WZ1Xk9K6MqGxamj0dz/Kq73gzMwI=" rel="preload stylesheet" as=style><link rel=icon href=http://udayv.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://udayv.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://udayv.com/favicon-32x32.png><link rel=apple-touch-icon href=http://udayv.com/apple-touch-icon.png><link rel=mask-icon href=http://udayv.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="Firebase with Clojure & core.async"><meta property="og:description" content="A walkthrough of adding a library function to pani using core.async and multi-methods."><meta property="og:type" content="article"><meta property="og:url" content="http://udayv.com/blog/2014-09-03-firebase-with-clojure-and-coreasync/"><meta property="article:published_time" content="2014-09-03T00:00:00+00:00"><meta property="article:modified_time" content="2014-09-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Firebase with Clojure & core.async"><meta name=twitter:description content="A walkthrough of adding a library function to pani using core.async and multi-methods."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"http://udayv.com/blog/"},{"@type":"ListItem","position":2,"name":"Firebase with Clojure \u0026 core.async","item":"http://udayv.com/blog/2014-09-03-firebase-with-clojure-and-coreasync/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Firebase with Clojure \u0026 core.async","name":"Firebase with Clojure \u0026 core.async","description":"A walkthrough of adding a library function to pani using core.async and multi-methods.","keywords":[],"articleBody":"You love Firebase? I love Firebase.\nWARNING: Fun with transducers ahead. Note that the use of transducers could have been totally avoided, but what’s the point if we’re not having a little fun, right? right?\nFirebase has made client side web-apps development trivial for me. I can forget about managing my data, pushing it, sanitizing it (may be a little) and retrieving it. These things may seem simple but having them taken care for you puts you in a different State of Mind which takes that data management burden out of your thought process.\nI’ve been working on a Firebase Clojure library called pani (hindi word for water). Things are flowing (no pun intended) nicely, although Clojure support is lagging behind ClojureScript (since I tend to use the latter more).\nIn this post I am going to touch on one aspect of pani. What I intend to do is write a function named listen which listens for events on Firebase refs and provides a nice way of dealing with them. We’d be using core.async to deliver these events.\nI originally intended to deconstruct these delivered events using core.match, but it seems like core.async and core.match don’t play nicely together yet.\nFirst things first The listen function will bind to Firebase events and wait for notifications. The function will return a core.async chan. Received Events will be posted to this channel as Clojure vectors. I will refrain from using certain functions from pani itself to make things clearer (although it could have resulted in more concise code).\nI am not going to show you the requires and stuff since this function will be a part of the pani library and requires have already been taken care of.\nBasic Structure I think the function should look something like:\n(defn listen \"Given a Firebase root and a key (or a seq of keys) return a channel which will deliver events\" [root korks] (let [c (chan)] c)) The function takes a Firebase root (can be created with pani/root function and either a single key or a seq of keys). We just declare a chan for now and return it.\nLet’s build on it.\nListening for Firebase Events Although pani already has functions to listen for Firebase events, let’s just re-write them here using some transducers for extra giggles.\nMostly we’re just interested in three Firebase events here: child_added, child_removed and child_changed (let’s collectively decide to not worry about child_moved). For most of my use cases I’ve found that I never need the previous snapshot or node name (let me know if that’s not the case though, or I’ll sooner or later hit one).\nFirst, let’s write a little function which takes a Firebase ref and returns to us a chan which will have the received value posted to it (pani/bind does something similar) after its passed through a provided transducer.\n(defn- fb-chan \"Given a firebase ref, an event and a transducer, binds and posts to returned channel\" [fbref event td] (let [c (chan 1 td)] (.on fbref (clojure.core/name event) #(put! c [event %])) c)) This function takes a Firebase ref, an event in the form of a keyword e.g. :child_added and a transducer. The function pushes values as a vector into the channel. The values look like [event-type firebase-snapshot], e.g. [:child_added #js {:firebase \"stuff\"}] (that #js is called a reader, basically saying what follows needs to be interpreted as a javascript object, makes more sense when you’re reading in code, hence the name).\nThe transducer then accepts this vector and turns it into a flattened out vector, something like [:child_added \"key name\" \"value\"]. Like I said before, we can totally not use a transducer here, but we’re just having a little bit of fun.\nTesting this is not a trivial thing to do, so you’d have to take my word for it that it’s working fine. If you really want to test it, you can create a new ClojureScript application, refer to pani and play around with it. Hint: a good starting point for ClojureScript apps is David Nolen’s mies.\nlisten Machinery Once we have the fb-chan method, we can starting defining our listen function. It looks something like this for me:\n(defn listen \"Listens for events on the given firebase ref\" [root korks] (let [root (walk-root root korks) events [:child_added :child_removed :child_changed] td (map (fn [[evt snap]] [evt (.name snap) (.val snap)])) chans (map (fn [event] (fb-chan root event td)) events)] (merge chans))) The function begins by taking care of any child refs we may need to get to using walk-root. This function works by walking up the refs, e.g.\n\"/\" - (walk-root [:hello :world]) - \"/hello/world\"  Next we list the events we are interested in, followed by our transducer which pulls the Firebase snapshot’s name and value out of the snapshot.\n[:child_added #js {:name \"1\" :value \"sup\"}] - [:child_added \"1\" \"sup\"]  A simple transformation.\nFinally we map over our events of interest and generate chans for each one of them using the fb-chan method.\nWe finally return a merged chan.\nUsing our new function To begin with, let’s just print what we receive.\n(def r (p/root \"https://secret-app.firebaseio.com/\")) (let [c (p/listen r [:items])] (go-loop [msg ( c)] (println msg) (recur ( c)))) We define r as the root of our Firebase app. We call listen on it and pass it [:items], since here we’re interested in /items ref. Any items added, removed or changed under this ref needs to be told us about. When I run this and simulate adding and removing values, I get output like this:\n[:child_added \"4\" \"clojure\"] [:child_added \"5\" \"rocks!\"] [:child_changed \"5\" \"rocks hard!\"] [:child_removed \"5\" \"rocks hard!\"]  Ok, so far so good.\nLet’s say I want to keep track of values under my Firebase ref. I would start with an empty map and as I receive notifications about items being added, removed or modified, I would update my map accordingly. A nice and pretty way of doing this would be to use clojure.match, but we’re going to stay away from it for now. Instead we’ll play a little bit with multi-methods.\nA whirlwind tour of Multi-methods Multi-methods you say?\nA mutli-method in its gist can be thought of as a dispatch table. Based on a certain value one of the defined methods of a multi-method will be called. This certain value is again computed by calling a function called a dispatch function. All arguments passed to the multi-method are passed to this dispatch function. The return value of the dispatch function then determines which of the functions from the dispatch table needs to be called.\nLet’s work on a simple example:\n(defmulti greet :message) (defmethod greet :bye [_] \"Goodbye\") (defmethod greet :hello [_] \"Hello\") Here we declare a multi-method named greet, the second parameter to defmulti is a function. Recall that a keyword can be called as a function on a map:\n(:message {:message \"what\"}) = \"what\" So its totally fine to use a keyword as a dispatch function for a multi-method as long as you’re expecting a map as the only parameter.\nNext, we define two cases for calling the multi-method. This is done using the defmethod form. We’re essentially telling Clojure which code to call for which return value of the dispatch function. When the dispatch function returns :bye return \"Goodbye\" and when it returns :hello, return \"Hello\". Since, here, we don’t really care about the arguments passed in we just use _ in parameter list. Read some more examples here. Let’s test it out:\n(greet {:message :bye}) = \"Goodbye\" (greent {:message :hello}) = \"Hello\" Mutli-methods are much broader in scope though, so if you find them interesting, read more about them. I’ve found that The Joy of Clojure has a pretty enlightening text on these.\nUsing multi-methods in our case Before we write our mutli-method, let’s try and see how we’re going to use it.\n(let [c (p/listen r [:items])] (go-loop [msg ( c) my-data {}] (let [new-data (handle-value msg my-data)] (println \"My data is now \" new-data) (recur ( c) new-data)))) We’re running a go-loop here listening for messages on channel c. We then pass the received message and the current value of my-data (our list of items) to our multi-method handle-value. handle-value is then supposed to return us the new state of our data.\nWe can define our multi-method like so:\n(defmethod handle-value #(first %1)) (defmethod handle-value :child_added [[_ k v] data] (assoc data k v)) (defmethod handle-value :child_removed [[_ k _] data] (dissoc data k)) (defmethod handle-value :child_changed [[_ k v] data] (assoc data k v)) We know that handle-value gets passed two arguments. The event type is the first element in the first argument. We pass a #(first %1) function as the dispatch function when defining the multi-method, which pulls the first element out of the first argument passed to the multi-method.\nThe defmethod form then defines the three situations we want to handle. These methods don’t do much other than associng and disassocing values into passed in data parameter.\nFinal output When I hookup all of this machinery and run the code. I get output like this:\nMy data is now {2 do} ;; [:child_added \"2\" \"do\"] My data is now {3 even, 2 do} ;; [:child_added \"3\" \"even\"] My data is now {3 even, ;; [:child_added \"4\" \"eat\"] 4 eat, 2 do} My data is now {3 even, ;; [:child_added \"5\" \"Hello\"] 4 eat, 5 Hello, 2 do} My data is now {3 event, ;; [:child_changed \"3\" \"event\"] 4 eat, 5 Hello, 2 do} My data is now {3 event, ;; [:child_removed \"4\" \"eat\"] 5 Hello, 2 do} My data is now {3 event, ;; [:child_removed \"2\" \"do\"] 5 Hello}  Things look good.\nConclusion Here are some of the things we discussed:\n Firebase Pani. core.async core.match mies The Joy of Clojure  Until next time!\n","wordCount":"1635","inLanguage":"en","datePublished":"2014-09-03T00:00:00Z","dateModified":"2014-09-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://udayv.com/blog/2014-09-03-firebase-with-clojure-and-coreasync/"},"publisher":{"@type":"Organization","name":"Uday Verma's Blog","logo":{"@type":"ImageObject","url":"http://udayv.com/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=http://udayv.com/ accesskey=h title="Uday Verma's Blog (Alt + H)">Uday Verma's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Firebase with Clojure & core.async</h1><section class=entry-tags><p>clojure</p></section><div class=post-meta>September 3, 2014&nbsp;·&nbsp;8 min</div></header><div class=post-content><p>You love <a href=https://www.firebase.com/>Firebase</a>? I love Firebase.</p><p><em>WARNING: Fun with transducers ahead. Note that the use of transducers could have been totally avoided, but what&rsquo;s the point if we&rsquo;re not having a little fun, right? right?</em></p><p>Firebase has made client side web-apps development trivial for me. I can forget about managing my data, pushing it, sanitizing it (may be a little) and retrieving it. These things may seem simple but having them taken care for you puts you in a different <em>State of Mind</em> which takes that data management burden out of your thought process.</p><p>I&rsquo;ve been working on a Firebase Clojure library called <a href=https://github.com/verma/pani>pani</a> (hindi word for water). Things are flowing (no pun intended) nicely, although Clojure support is lagging behind ClojureScript (since I tend to use the latter more).</p><p>In this post I am going to touch on one aspect of pani. What I intend to do is write a function named <code>listen</code> which listens for events on Firebase <code>refs</code> and provides a nice way of dealing with them. We&rsquo;d be using <code>core.async</code> to deliver these events.</p><p><em>I originally intended to deconstruct these delivered events using <code>core.match</code>, but it seems like <code>core.async</code> and <code>core.match</code> <a href=http://dev.clojure.org/jira/browse/MATCH-96>don&rsquo;t play nicely together yet</a></em>.</p><h3 id=first-things-first>First things first<a hidden class=anchor aria-hidden=true href=#first-things-first>#</a></h3><p>The <code>listen</code> function will bind to Firebase events and wait for notifications. The function will return a <code>core.async</code> <code>chan</code>.
Received <em>Events</em> will be posted to this channel as Clojure vectors. I will refrain from using certain functions from <em>pani</em> itself to make things clearer (although it could have resulted in more concise code).</p><p>I am not going to show you the requires and stuff since this function will be a part of the <em>pani</em> library and requires have already <a href=https://github.com/verma/pani/blob/master/src/pani/cljs/core.cljs#L1>been taken care of</a>.</p><h3 id=basic-structure>Basic Structure<a hidden class=anchor aria-hidden=true href=#basic-structure>#</a></h3><p>I think the function should look something like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>listen
  <span style=color:#e6db74>&#34;Given a Firebase root and a key (or a seq of keys) return a
</span><span style=color:#e6db74>   channel which will deliver events&#34;</span>
  [root korks]
  (<span style=color:#66d9ef>let </span>[c (<span style=color:#a6e22e>chan</span>)]
    c))</code></pre></div><p>The function takes a Firebase root (can be created with <code>pani/root</code> function and either a single key or a seq of keys). We just declare a <code>chan</code> for now and return it.</p><p>Let&rsquo;s build on it.</p><h3 id=listening-for-firebase-events>Listening for Firebase Events<a hidden class=anchor aria-hidden=true href=#listening-for-firebase-events>#</a></h3><p>Although <em>pani</em> already has functions to listen for Firebase events, let&rsquo;s just re-write them here using some transducers for extra giggles.</p><p>Mostly we&rsquo;re just interested in three Firebase events here: <code>child_added</code>, <code>child_removed</code> and <code>child_changed</code> (let&rsquo;s collectively decide to not worry about <code>child_moved</code>). For most of my use cases I&rsquo;ve found that I never need the previous snapshot or node name (let me know if that&rsquo;s not the case though, or I&rsquo;ll sooner or later hit one).</p><p>First, let&rsquo;s write a little function which takes a Firebase ref and returns to us a <code>chan</code> which will have the received value posted to it (<code>pani/bind</code> does something similar) after its passed through a provided transducer.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn- </span>fb-&gt;chan
  <span style=color:#e6db74>&#34;Given a firebase ref, an event and a transducer, binds and posts to returned channel&#34;</span>
  [fbref event td]
  (<span style=color:#66d9ef>let </span>[c (<span style=color:#a6e22e>chan</span> <span style=color:#ae81ff>1</span> td)]
    (<span style=color:#a6e22e>.on</span> fbref (<span style=color:#a6e22e>clojure.core/name</span> event)
         <span style=color:#f92672>#</span>(<span style=color:#a6e22e>put!</span> c [event %]))
    c))</code></pre></div><p>This function takes a Firebase ref, an event in the form of a keyword e.g. <code>:child_added</code> and a transducer. The function pushes values as a vector into the channel. The values look like <code>[event-type firebase-snapshot]</code>, e.g. <code>[:child_added #js {:firebase "stuff"}]</code> (that <code>#js</code> is called a <em>reader</em>, basically saying what follows needs to be interpreted as a javascript object, makes more sense when you&rsquo;re reading in code, hence the name).</p><p>The transducer then accepts this vector and turns it into a flattened out vector, something like <code>[:child_added "key name" "value"]</code>. Like I said before, we can totally not use a transducer here, but we&rsquo;re just having a little bit of fun.</p><p>Testing this is not a trivial thing to do, so you&rsquo;d have to take my word for it that it&rsquo;s working fine. If you really want to test it, you can create a new ClojureScript application, refer to <em>pani</em> and play around with it. <em>Hint: a good starting point for ClojureScript apps is David Nolen&rsquo;s <a href=https://github.com/swannodette/mies>mies</a></em>.</p><h3 id=listen-machinery><code>listen</code> Machinery<a hidden class=anchor aria-hidden=true href=#listen-machinery>#</a></h3><p>Once we have the <code>fb->chan</code> method, we can starting defining our <code>listen</code> function. It looks something like this for me:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>listen
  <span style=color:#e6db74>&#34;Listens for events on the given firebase ref&#34;</span>
  [root korks]
  (<span style=color:#66d9ef>let </span>[root    (<span style=color:#a6e22e>walk-root</span> root korks)
        events  [<span style=color:#e6db74>:child_added</span> <span style=color:#e6db74>:child_removed</span> <span style=color:#e6db74>:child_changed</span>]
        td      (map (<span style=color:#66d9ef>fn </span>[[evt snap]]
                       [evt (<span style=color:#a6e22e>.name</span> snap) (<span style=color:#a6e22e>.val</span> snap)]))
        chans   (map (<span style=color:#66d9ef>fn </span>[event]
                       (<span style=color:#a6e22e>fb-&gt;chan</span> root event td)) events)]
    (merge chans)))</code></pre></div><p>The function begins by taking care of any child refs we may need to get to using <code>walk-root</code>. This function works by walking up the refs, e.g.</p><pre><code>&quot;/&quot; -&gt; (walk-root [:hello :world]) -&gt; &quot;/hello/world&quot;
</code></pre><p>Next we list the <code>events</code> we are interested in, followed by our transducer which pulls the Firebase snapshot&rsquo;s name and value out of the snapshot.</p><pre><code>[:child_added #js {:name &quot;1&quot; :value &quot;sup&quot;}] -&gt;
    [:child_added &quot;1&quot; &quot;sup&quot;]
</code></pre><p>A simple transformation.</p><p>Finally we map over our events of interest and generate <code>chan</code>s for each one of them using the <code>fb->chan</code> method.</p><p>We finally return a merged <code>chan</code>.</p><h3 id=using-our-new-function>Using our new function<a hidden class=anchor aria-hidden=true href=#using-our-new-function>#</a></h3><p>To begin with, let&rsquo;s just print what we receive.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>r (<span style=color:#a6e22e>p/root</span> <span style=color:#e6db74>&#34;https://secret-app.firebaseio.com/&#34;</span>))

(<span style=color:#66d9ef>let </span>[c (<span style=color:#a6e22e>p/listen</span> r [<span style=color:#e6db74>:items</span>])]
  (<span style=color:#a6e22e>go-loop</span> [msg (<span style=color:#a6e22e>&lt;!</span> c)]
           (println msg)
           (<span style=color:#a6e22e>recur</span> (<span style=color:#a6e22e>&lt;!</span> c))))</code></pre></div><p>We define <code>r</code> as the root of our Firebase app. We call <code>listen</code> on it and pass it <code>[:items]</code>, since here we&rsquo;re interested in <code>/items</code> ref. Any items added, removed or changed under this ref needs to be told us about. When I run this and simulate adding and removing values, I get output like this:</p><pre><code>[:child_added &quot;4&quot; &quot;clojure&quot;]
[:child_added &quot;5&quot; &quot;rocks!&quot;]
[:child_changed &quot;5&quot; &quot;rocks hard!&quot;]
[:child_removed &quot;5&quot; &quot;rocks hard!&quot;]
</code></pre><p>Ok, so far so good.</p><p>Let&rsquo;s say I want to keep track of values under my Firebase ref. I would start with an empty map and as I receive notifications about items being added, removed or modified, I would update my map accordingly. A nice and pretty way of doing this would be to use <code>clojure.match</code>, but we&rsquo;re going to stay away from it for now. Instead we&rsquo;ll play a little bit with <em>multi-methods</em>.</p><h3 id=a-whirlwind-tour-of-multi-methods>A whirlwind tour of Multi-methods<a hidden class=anchor aria-hidden=true href=#a-whirlwind-tour-of-multi-methods>#</a></h3><p><em>Multi-methods</em> you say?</p><p>A mutli-method in its gist can be thought of as a dispatch table. Based on a certain value one of the defined methods of a multi-method will be called. This <em>certain value</em> is again computed by calling a function called a <em>dispatch function</em>. All arguments passed to the multi-method are passed to this <em>dispatch function</em>. The return value of the <em>dispatch function</em> then determines which of the functions from the <em>dispatch table</em> needs to be called.</p><p>Let&rsquo;s work on a simple example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defmulti </span>greet <span style=color:#e6db74>:message</span>)

(<span style=color:#66d9ef>defmethod </span>greet <span style=color:#e6db74>:bye</span> [_]
  <span style=color:#e6db74>&#34;Goodbye&#34;</span>)

(<span style=color:#66d9ef>defmethod </span>greet <span style=color:#e6db74>:hello</span> [_]
  <span style=color:#e6db74>&#34;Hello&#34;</span>)</code></pre></div><p>Here we declare a multi-method named greet, the second parameter to <code>defmulti</code> is a function. Recall that a keyword can be called as a function on a map:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#e6db74>:message</span> {<span style=color:#e6db74>:message</span> <span style=color:#e6db74>&#34;what&#34;</span>})
=&gt; <span style=color:#e6db74>&#34;what&#34;</span></code></pre></div><p>So its totally fine to use a keyword as a <em>dispatch function</em> for a multi-method as long as you&rsquo;re expecting a map as the only parameter.</p><p>Next, we define two cases for calling the multi-method. This is done using the <code>defmethod</code> form. We&rsquo;re essentially telling Clojure which code to call for which return value of the <em>dispatch function</em>. When the <em>dispatch function</em> returns <code>:bye</code> return <code>"Goodbye"</code> and when it returns <code>:hello</code>, return <code>"Hello"</code>. Since, here, we don&rsquo;t really care about the arguments passed in we just use <code>_</code> in parameter list. Read some more examples <a href=http://clojuredocs.org/clojure_core/clojure.core/defmulti>here</a>. Let&rsquo;s test it out:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>greet</span> {<span style=color:#e6db74>:message</span> <span style=color:#e6db74>:bye</span>})
=&gt; <span style=color:#e6db74>&#34;Goodbye&#34;</span>

(<span style=color:#a6e22e>greent</span> {<span style=color:#e6db74>:message</span> <span style=color:#e6db74>:hello</span>})
=&gt; <span style=color:#e6db74>&#34;Hello&#34;</span></code></pre></div><p>Mutli-methods are much broader in scope though, so if you find them interesting, read more about them. I&rsquo;ve found that <a href=http://joyofclojure.com/>The Joy of Clojure</a> has a pretty enlightening text on these.</p><h3 id=using-multi-methods-in-our-case>Using multi-methods in our case<a hidden class=anchor aria-hidden=true href=#using-multi-methods-in-our-case>#</a></h3><p>Before we write our mutli-method, let&rsquo;s try and see how we&rsquo;re going to use it.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>let </span>[c (<span style=color:#a6e22e>p/listen</span> r [<span style=color:#e6db74>:items</span>])]
  (<span style=color:#a6e22e>go-loop</span> [msg (<span style=color:#a6e22e>&lt;!</span> c)
            my-data {}]
           (<span style=color:#66d9ef>let </span>[new-data (<span style=color:#a6e22e>handle-value</span> msg my-data)]
             (println <span style=color:#e6db74>&#34;My data is now &#34;</span> new-data)
             (<span style=color:#a6e22e>recur</span> (<span style=color:#a6e22e>&lt;!</span> c) new-data))))</code></pre></div><p>We&rsquo;re running a <code>go-loop</code> here listening for messages on channel <code>c</code>. We then pass the received message and the current value of <code>my-data</code> (our <em>list</em> of items) to our multi-method <code>handle-value</code>. <code>handle-value</code> is then supposed to return us the new state of our data.</p><p>We can define our multi-method like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defmethod </span>handle-value <span style=color:#f92672>#</span>(first %1))

(<span style=color:#66d9ef>defmethod </span>handle-value <span style=color:#e6db74>:child_added</span> [[_ k v] data]
  (assoc data k v))

(<span style=color:#66d9ef>defmethod </span>handle-value <span style=color:#e6db74>:child_removed</span> [[_ k _] data]
  (dissoc data k))

(<span style=color:#66d9ef>defmethod </span>handle-value <span style=color:#e6db74>:child_changed</span> [[_ k v] data]
  (assoc data k v))</code></pre></div><p>We know that <code>handle-value</code> gets passed two arguments. The event type is the first element in the first argument. We pass a <code>#(first %1)</code> function as the <em>dispatch function</em> when defining the multi-method, which pulls the first element out of the first argument passed to the multi-method.</p><p>The <code>defmethod</code> form then defines the three situations we want to handle. These methods don&rsquo;t do much other than <code>assoc</code>ing and <code>disassoc</code>ing values into passed in <code>data</code> parameter.</p><h3 id=final-output>Final output<a hidden class=anchor aria-hidden=true href=#final-output>#</a></h3><p>When I hookup all of this machinery and run the code. I get output like this:</p><pre><code>My data is now  {2 do}         ;; [:child_added &quot;2&quot; &quot;do&quot;]

My data is now  {3 even, 2 do} ;; [:child_added &quot;3&quot; &quot;even&quot;]

My data is now  {3 even,       ;; [:child_added &quot;4&quot; &quot;eat&quot;]
                 4 eat, 2 do}

My data is now  {3 even,       ;; [:child_added &quot;5&quot; &quot;Hello&quot;]
                 4 eat,
                 5 Hello, 2 do}

My data is now  {3 event,      ;; [:child_changed &quot;3&quot; &quot;event&quot;]
                 4 eat,
                 5 Hello, 2 do}

My data is now  {3 event,      ;; [:child_removed &quot;4&quot; &quot;eat&quot;]
                 5 Hello, 2 do}
My data is now  {3 event,      ;; [:child_removed &quot;2&quot; &quot;do&quot;]
                 5 Hello}
</code></pre><p>Things look good.</p><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>Here are some of the things we discussed:</p><ul><li><a href=https://www.firebase.com/>Firebase</a></li><li><a href=https://github.com/verma/pani>Pani</a>.</li><li><a href=https://github.com/clojure/core.async>core.async</a></li><li><a href=https://github.com/clojure/core.match>core.match</a></li><li><a href=https://github.com/swannodette/mies>mies</a></li><li><a href=http://joyofclojure.com/>The Joy of Clojure</a></li></ul><p>Until next time!</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=http://udayv.com/>Uday Verma's Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>