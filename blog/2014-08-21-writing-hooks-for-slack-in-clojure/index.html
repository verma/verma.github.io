<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Writing Slack integrations in Clojure | Uday Verma's Blog</title><meta name=keywords content><meta name=description content="Slack integrations are awesome, in this series we&rsquo;ll develop an integration which will help us do something useful."><meta name=author content><link rel=canonical href=http://udayv.com/blog/2014-08-21-writing-hooks-for-slack-in-clojure/><link href=/assets/css/stylesheet.min.3dac925eb9bf5bf78d5d4e966755e4f4ae8ca86c5a9a3d1dcff2aaef78333302.css integrity="sha256-PaySXrm/W/eNXU6WZ1Xk9K6MqGxamj0dz/Kq73gzMwI=" rel="preload stylesheet" as=style><link rel=icon href=http://udayv.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://udayv.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://udayv.com/favicon-32x32.png><link rel=apple-touch-icon href=http://udayv.com/apple-touch-icon.png><link rel=mask-icon href=http://udayv.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="Writing Slack integrations in Clojure"><meta property="og:description" content="Slack integrations are awesome, in this series we&rsquo;ll develop an integration which will help us do something useful."><meta property="og:type" content="article"><meta property="og:url" content="http://udayv.com/blog/2014-08-21-writing-hooks-for-slack-in-clojure/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Writing Slack integrations in Clojure"><meta name=twitter:description content="Slack integrations are awesome, in this series we&rsquo;ll develop an integration which will help us do something useful."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"http://udayv.com/blog/"},{"@type":"ListItem","position":2,"name":"Writing Slack integrations in Clojure","item":"http://udayv.com/blog/2014-08-21-writing-hooks-for-slack-in-clojure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Writing Slack integrations in Clojure","name":"Writing Slack integrations in Clojure","description":"Slack integrations are awesome, in this series we\u0026amp;rsquo;ll develop an integration which will help us do something useful.","keywords":[],"articleBody":"I’ve been playing a lot with Slack lately. At Mazira, it has become an integral part of our workflow, and it hasn’t been very long since we started using it. Some things are love at first sight and I feel Slack is one of them.\nWhat are we doing? This exercise is not intended to be a tutorial on writing Slack Integrations, it’s more like doing fun stuff in Clojure.\nSource code is available here.\nWe’ll setup a basic project in Clojure and build a Slack integration. We’d be querying OpenWeatherMap for weather information for the given zip code. I guess it’s nice to know how it is outside when you spend your entire day inside, on a computer, writing Clojure.\nOpenWeatherMap provides weather over a freely accessible API which returns results in JSON. Try this.\nOn the Slack side of things, you need to setup an Incoming Webhook. Details for doing that can be found here. You should eventually end up with a URL to which you can post well-defined data.\nSetting up the projects Let’s begin by starting a new project.\nlein new compojure slack-weather  This will create a new project for you named slack-weather using the compojure template.\nWe’re going to import some dependencies. I like to use clj-http for making web-requests, data.json for manipulating JSON and core.async for general awesomeness (for the thread function actually). Let’s add these deps to the project.clj file. After you’re done making changes it should look something like:\n(defproject slack-weather \"0.1.0-SNAPSHOT\" :description \"FIXME: write description\" :url \"http://example.com/FIXME\" :dependencies [[org.clojure/clojure \"1.6.0\"] [compojure \"1.1.8\"] [org.clojure/data.json \"0.2.5\"] [org.clojure/core.async \"0.1.319.0-6b1aca-alpha\"] [clj-http \"1.0.0\"]] :plugins [[lein-ring \"0.8.11\"]] :ring {:handler slack-weather.handler/app} :profiles {:dev {:dependencies [[javax.servlet/servlet-api \"2.5\"] [ring-mock \"0.1.5\"]]}}) I use vim-fireplace for Clojure development, so what you do here may vary. Let’s open a terminal window, navigate to the project directory and start a REPL.\nlein repl  When the REPL is running, you can go back to your VIM and :Connect to it. Please refer to vim-fireplace instructions on how to go about it.\nMoving forward We’ll start with some exploratory stuff and then build upon it. Open the src/slack_weather/handler.clj file in VIM. Go to the namespace definition section to require the things we need. Since we’re not going jump ahead of ourselves, let’s just include clj-http for now and go from there. Your namespace definition should look something like this once you’re done:\n(ns slack-weather.handler (:require [compojure.core :refer :all] [compojure.handler :as handler] [compojure.route :as route] [clj-http.client :as client])) Place your cursor on the outermost form (where it says ns) and hit cpp to get the expression evaluated. If all went well, you should see a nil print out in VIM’s command buffer.\nAt this point we have the clj-http.client library(among other things) included. Let’s play with it.\nHit cqc and a quasi-REPL window will open. Type in the following and hit enter:\n(client/get \"http://www.google.com\") Something should happen. Page full of content. Hit q to get out of it. At this point we’re ready to post messages to slack, but first let’s assign the Slack URL to something more convenient:\n(def hook-url \"https://myslack.slack.com/...\") ; use your real URL Now let’s write a function which takes a URL and a map (which will hold our content) and posts it to the given URL. Since we need to emit JSON (which is what Slack accepts), make sure you require [clojure.data.json :as json] and re-eval your namespace definition (cpp in fireplace).\n(defn post-to-slack [url msg] (client/post url {:body (json/write-str msg) :content-type :json})) Let’s eval (cpp in fireplace) this expression, along with the hook-url expression and open the quasi-REPL (cqc in fireplace). Try calling this function a few times:\n(post-to-slack hook-url {:text \"Test message\"}) (post-to-slack hook-url {:text \"Another message\" :username \"SASSY BOT\" :icon_emoji \":feelsgood:\"}) ;; more exciting Seems to be working alright. Let’s add the username and icon_emoji fields as defaults unless explicitly overridden by the caller.\n(defn post-to-slack [url msg] (let [m (merge {:username \"SASSY BOT\" :icon_emoji \":feelsgood:\"} msg)] (client/post url {:body (json/write-str m) :content-type :json}))) This method now provides some overridable defaults: (post-to-slack hook-url {:text \"Should have :feelsgood: icon\"}) (post-to-slack hook-url {:text \"Should have 😎 icon\" :icon_emoji \"😎\"})\nSeems like we’ve got posting to Slack down, so it’s time to move on to getting some real data.\nGetting Real Data Let’s now build a suite of functions which make its easier to deal with OpenWeatherMap data. First let’s just try to query the weather information and see what we get (hint: use cqc in fireplace):\n(client/get \"http://api.openweathermap.org/data/2.5/find?q=95136,USA\u0026units=imperial\") Seems like we got something back. The returned content is still a string, let’s start wrapping this in a function:\n(defn weather-for-zip [zip] (let [content (- (str \"http://api.openweathermap.org/data/2.5/find?q=\" zip \",USA\u0026units=imperial\") client/get :body json/read-str)] content)) Our data of interest is laid out in objects inside objects. e.g.\nname - list[0].name temp - list[0].main.temp humidity - list[0].main.humidity temp-min - list[0].main.temp_min temp-max - list[0].main.temp_max conditions - list[0].weather[0].main  Although we can manually pull these values out, let’s go a step further and brew up a function that does it for us.\n(defn pull-values [m val-map] (into {} (for [[k v] val-map] [k (get-in m (if (sequential? v) v [v]))]))) This function takes a map m to pull values out of and another map val-map which tells it which values to pull and what to assign them to.\nWe can use this function to pull our items of interest out of the OpenWeatherMap data.\n(defn weather-for-zip [zip] (- (str \"http://api.openweathermap.org/data/2.5/find?q=\" zip \",USA\u0026units=imperial\") client/get :body json/read-str (pull-values {:name [\"list\" 0 \"name\"] :temp [\"list\" 0 \"main\" \"temp\"] :humidity [\"list\" 0 \"main\" \"humidity\"] :temp-min [\"list\" 0 \"main\" \"temp_min\"] :temp-max [\"list\" 0 \"main\" \"temp_max\"] :conditions [\"list\" 0 \"weather\" 0 \"main\"]}))) We’ve gotten rid of the content def along with adding the pull-value call. Try this out in REPL (cpp and cqc in fireplace) and see if we’re getting awesome results. Feel free to pull out more information like wind speed, direction etc.\nFormatting Results We now need to convert this hash-map of weather data into a nicer looking string representation. Let’s write a function which does that:\n(defn weather-to-str [w] (str (:name w) \" \" (:temp w) \"F \" (:conditions w) \", Min: \" (:temp-min w) \"F, Max: \" (:temp-max w) \"F\" \", Humidity: \" (:humidity w)) This should give you a reasonable-looking weather string.\nPutting things together At this point we have all the pieces to post weather information to slack.\n(defn weather-to-slack [zip] (let [weather (- zip weather-for-zip weather-to-str)] (post-to-slack hook-url {:text weather :icon_emoji \"☁️\"}))) This function puts all the pieces together, taking a zip code and pushing the relevant weather information to the hook-url Slack URL.\nAccepting Commands So far we’ve just been playing with the REPL, building our functions to fetch weather information and pushing it to Slack. We did start the project using a Compojure template, but we haven’t used any web server functionality.\nSlack Commands work by pushing information to a URL you provide. Try creating a Slack Command integration and it will give you details about what parameters Slack is going to send to you. Basically, whenever you type in /command-name in one of the channels, the Slack command gets triggered.\nYour request handler is then supposed to return a string representing the result of the command. I like to send a progress message back, something like “Please wait…” and then do an actual post to the channel (using all of the stuff we’ve already built) when I have the data available (weather information in our case).\nSlack also sends you a token, which you should validate before accepting and processing a request.\nAt this time, I would open another terminal window, navigate to my project directory and run the ring server.\nlein ring server  This will serve the web service on port 3000 by default and will auto-update itself every time you modify the project source files.\nLet’s first set the basic Compojure handler to accept incoming commands. My defroutes definition now looks like this:\n(defroutes app-routes (POST \"/slack\" request {:status 200 :content-type \"text/plain\" :body \"Getting weather information, please wait.\"}) (route/resources \"/\") (route/not-found \"Not Found\")) Now setup a Slack Command Integration which will give the token information. When setting up the integration, Slack is going to ask you for the URL where it should post the command information. Since we’re developing our stuff locally and don’t really have a publicly accessible end-point, I usually run a tunneling software like ngrok to expose my services to the interwebs. ngrok will give you a URL where your service is reachable. Copy it and give it to Slack.\nYou should now be able to go to a channel and just type in /weather. You should see our response string popup.\nThe parameters will arrive under (:params request). :command will contain the actual command (you can have multiple commands go to a single server). :text will contain any additional parameters sent to us .e.g the zip code. Let’s do some error checking and see how things go.\n(defn check-zip [zip] (re-matches #\"^\\d{5}$\" (clojure.string/trim zip))) (defroutes app-routes (POST \"/slack\" {:keys [params] :as request} (if (and (= \"/weather\" (:command params)) (= auth-token (:token params)) (check-zip (:text params))) {:status 200 :content-type \"text/plain\" :body \"Getting weather information, please wait.\"} {:status 400 :content-type \"text/plain\" :body \"You need to provide a valid zip code\"})) (route/resources \"/\") (route/not-found \"Not Found\")) We first write a function check-zip which makes sure that provided zip codes are 5 digit numbers and spaces on either side of input are trimmed.\nFor the request to be valid, the :command field needs to say \"/command\", the auth token needs to match the token we were given when we created the command integration and finally the zip code that arrived in :text needs to be valid. Play around with this either in your REPL or from the Slack channel window. I did reasonable amount of testing (2 mins) to make sure things were working.\nRight now we just have the request returning a status message back to Slack. We’re not really doing any actual work. We should now hook in our weather query machinery from before into this request handler, something like:\n(defroutes app-routes (POST \"/slack\" {:keys [params] :as request} (if (and (= \"/weather\" (:command params)) (= auth-token (:token params)) (check-zip (:text params))) (do (thread (weather-to-slack (clojure.string/trim (:text params)))) {:status 200 :content-type \"text/plain\" :body \"Getting weather information, please wait.\"}) {:status 400 :content-type \"text/plain\" :body \"You need to provide a valid zip code\"})) (route/resources \"/\") (route/not-found \"Not Found\")) Remember to refer to thread call by requiring [clojure.core.async :refer [thread]]. On a valid request we run our weather machinery in a separate thread, which eventually gets the data and posts it to the configured channel.\nConclusion Hopefully it was a fun ride getting this to work. Some of the things referred to in this post:\n Slack Clojure Compojure OpenWeatherMap vim-fireplace ngrok  If you’re feeling particularly generous today, follow me on Twitter.\nCredits Thanks to Liz Silich for proof-reading this post.\n","wordCount":"1816","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://udayv.com/blog/2014-08-21-writing-hooks-for-slack-in-clojure/"},"publisher":{"@type":"Organization","name":"Uday Verma's Blog","logo":{"@type":"ImageObject","url":"http://udayv.com/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=http://udayv.com/ accesskey=h title="Uday Verma's Blog (Alt + H)">Uday Verma's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Writing Slack integrations in Clojure</h1><section class=entry-tags><p>clojure</p></section><div class=post-meta>9 min</div></header><div class=post-content><p>I&rsquo;ve been playing a lot with Slack lately. At <a href=https://www.mazira.com/>Mazira</a>, it has become an integral part of our workflow, and it hasn&rsquo;t been very long since we started using it. Some things are love at first sight and I feel Slack is one of them.</p><h3 id=what-are-we-doing>What are we doing?<a hidden class=anchor aria-hidden=true href=#what-are-we-doing>#</a></h3><p>This exercise is not intended to be a tutorial on writing Slack Integrations, it&rsquo;s more like doing fun stuff in Clojure.</p><p>Source code is available <a href=https://github.com/verma/slack-weather>here</a>.</p><p>We&rsquo;ll setup a basic project in Clojure and build a Slack integration. We&rsquo;d be querying <a href=http://openweathermap.org/>OpenWeatherMap</a> for weather information for the given zip code. I guess it&rsquo;s nice to know how it is outside when you spend your entire day inside, on a computer, writing Clojure.</p><p>OpenWeatherMap provides weather over a freely accessible API which returns results in JSON. <a href="http://api.openweathermap.org/data/2.5/find?q=95136,USA&units=imperial">Try this</a>.</p><p>On the Slack side of things, you need to setup an <em>Incoming Webhook</em>. Details for doing that can be found <a href=https://my.slack.com/services/new/incoming-webhook>here</a>. You should eventually end up with a URL to which you can post well-defined data.</p><h3 id=setting-up-the-projects>Setting up the projects<a hidden class=anchor aria-hidden=true href=#setting-up-the-projects>#</a></h3><p>Let&rsquo;s begin by starting a new project.</p><pre><code>lein new compojure slack-weather
</code></pre><p>This will create a new project for you named <code>slack-weather</code> using the <code>compojure</code> template.</p><p>We&rsquo;re going to import some dependencies. I like to use <a href=https://github.com/dakrone/clj-http>clj-http</a> for making web-requests, <a href=https://github.com/clojure/data.json>data.json</a> for manipulating JSON and <a href=https://github.com/clojure/core.async>core.async</a> for general awesomeness (for the <code>thread</code> function actually). Let&rsquo;s add these deps to the <code>project.clj</code> file. After you&rsquo;re done making changes it should look something like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defproject </span>slack-weather <span style=color:#e6db74>&#34;0.1.0-SNAPSHOT&#34;</span>
  <span style=color:#e6db74>:description</span> <span style=color:#e6db74>&#34;FIXME: write description&#34;</span>
  <span style=color:#e6db74>:url</span> <span style=color:#e6db74>&#34;http://example.com/FIXME&#34;</span>
  <span style=color:#e6db74>:dependencies</span> [[org.clojure/clojure <span style=color:#e6db74>&#34;1.6.0&#34;</span>]
                 [compojure <span style=color:#e6db74>&#34;1.1.8&#34;</span>]
                 [org.clojure/data.json <span style=color:#e6db74>&#34;0.2.5&#34;</span>]
                 [org.clojure/core.async <span style=color:#e6db74>&#34;0.1.319.0-6b1aca-alpha&#34;</span>]
                 [clj-http <span style=color:#e6db74>&#34;1.0.0&#34;</span>]]
  <span style=color:#e6db74>:plugins</span> [[lein-ring <span style=color:#e6db74>&#34;0.8.11&#34;</span>]]
  <span style=color:#e6db74>:ring</span> {<span style=color:#e6db74>:handler</span> slack-weather.handler/app}
  <span style=color:#e6db74>:profiles</span>
  {<span style=color:#e6db74>:dev</span> {<span style=color:#e6db74>:dependencies</span> [[javax.servlet/servlet-api <span style=color:#e6db74>&#34;2.5&#34;</span>]
                        [ring-mock <span style=color:#e6db74>&#34;0.1.5&#34;</span>]]}})</code></pre></div><p>I use <a href=https://github.com/tpope/vim-fireplace>vim-fireplace</a> for Clojure development, so what you do here may vary. Let&rsquo;s open a terminal window, navigate to the project directory and start a REPL.</p><pre><code>lein repl
</code></pre><p>When the REPL is running, you can go back to your VIM and <code>:Connect</code> to it. Please refer to vim-fireplace instructions on how to go about it.</p><h3 id=moving-forward>Moving forward<a hidden class=anchor aria-hidden=true href=#moving-forward>#</a></h3><p>We&rsquo;ll start with some exploratory stuff and then build upon it. Open the <code>src/slack_weather/handler.clj</code> file in VIM. Go to the namespace definition section to require the things we need. Since we&rsquo;re not going jump ahead of ourselves, let&rsquo;s just include <code>clj-http</code> for now and go from there. Your namespace definition should look something like this once you&rsquo;re done:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>ns </span>slack-weather.handler
  (<span style=color:#e6db74>:require</span> [compojure.core <span style=color:#e6db74>:refer</span> <span style=color:#e6db74>:all</span>]
            [compojure.handler <span style=color:#e6db74>:as</span> handler]
            [compojure.route <span style=color:#e6db74>:as</span> route]
            [clj-http.client <span style=color:#e6db74>:as</span> client]))</code></pre></div><p>Place your cursor on the outermost form (where it says <code>ns</code>) and hit <code>cpp</code> to get the expression evaluated. If all went well, you should see a <code>nil</code> print out in VIM&rsquo;s command buffer.</p><p>At this point we have the <code>clj-http.client</code> library(among other things) included. Let&rsquo;s play with it.</p><p>Hit <code>cqc</code> and a <em>quasi-REPL</em> window will open. Type in the following and hit enter:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>client/get</span> <span style=color:#e6db74>&#34;http://www.google.com&#34;</span>)</code></pre></div><p>Something should happen. Page full of content. Hit q to get out of it. At this point we&rsquo;re ready to post messages to slack, but first let&rsquo;s assign the Slack URL to something more convenient:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>hook-url <span style=color:#e6db74>&#34;https://myslack.slack.com/...&#34;</span>) <span style=color:#75715e>; use your real URL</span></code></pre></div><p>Now let&rsquo;s write a function which takes a URL and a map (which will hold our content) and posts it to the given URL. Since we need to emit JSON (which is what Slack accepts), make sure you require <code>[clojure.data.json :as json]</code> and re-eval your namespace definition (<code>cpp</code> in fireplace).</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>post-to-slack [url msg]
  (<span style=color:#a6e22e>client/post</span> url {<span style=color:#e6db74>:body</span> (<span style=color:#a6e22e>json/write-str</span> msg)
                    <span style=color:#e6db74>:content-type</span> <span style=color:#e6db74>:json</span>}))</code></pre></div><p>Let&rsquo;s eval (<code>cpp</code> in fireplace) this expression, along with the <code>hook-url</code> expression and open the <em>quasi-REPL</em> (<code>cqc</code> in fireplace). Try calling this function a few times:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>post-to-slack</span> hook-url {<span style=color:#e6db74>:text</span> <span style=color:#e6db74>&#34;Test message&#34;</span>})
(<span style=color:#a6e22e>post-to-slack</span> hook-url {<span style=color:#e6db74>:text</span> <span style=color:#e6db74>&#34;Another message&#34;</span>
                         <span style=color:#e6db74>:username</span> <span style=color:#e6db74>&#34;SASSY BOT&#34;</span>
                         <span style=color:#e6db74>:icon_emoji</span> <span style=color:#e6db74>&#34;:feelsgood:&#34;</span>}) <span style=color:#75715e>;; more exciting</span></code></pre></div><p>Seems to be working alright. Let&rsquo;s add the <code>username</code> and <code>icon_emoji</code> fields as defaults unless explicitly overridden by the caller.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>post-to-slack [url msg]
  (<span style=color:#66d9ef>let </span>[m (merge {<span style=color:#e6db74>:username</span> <span style=color:#e6db74>&#34;SASSY BOT&#34;</span>
                  <span style=color:#e6db74>:icon_emoji</span> <span style=color:#e6db74>&#34;:feelsgood:&#34;</span>} msg)]
    (<span style=color:#a6e22e>client/post</span> url {<span style=color:#e6db74>:body</span> (<span style=color:#a6e22e>json/write-str</span> m)
                      <span style=color:#e6db74>:content-type</span> <span style=color:#e6db74>:json</span>})))</code></pre></div><p>This method now provides some overridable defaults:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>post-to-slack</span> hook-url {<span style=color:#e6db74>:text</span> <span style=color:#e6db74>&#34;Should have :feelsgood: icon&#34;</span>})
(<span style=color:#a6e22e>post-to-slack</span> hook-url {<span style=color:#e6db74>:text</span> <span style=color:#e6db74>&#34;Should have 😎 icon&#34;</span>
                         <span style=color:#e6db74>:icon_emoji</span> <span style=color:#e6db74>&#34;😎&#34;</span>})</code></pre></div></p><p>Seems like we&rsquo;ve got posting to Slack down, so it&rsquo;s time to move on to getting some real data.</p><h3 id=getting-real-data>Getting Real Data<a hidden class=anchor aria-hidden=true href=#getting-real-data>#</a></h3><p>Let&rsquo;s now build a suite of functions which make its easier to deal with OpenWeatherMap data. First let&rsquo;s just try to query the weather information and see what we get (hint: use <code>cqc</code> in fireplace):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>client/get</span> <span style=color:#e6db74>&#34;http://api.openweathermap.org/data/2.5/find?q=95136,USA&amp;units=imperial&#34;</span>)</code></pre></div><p>Seems like we got something back. The returned content is still a string, let&rsquo;s start wrapping this in a function:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>weather-for-zip [zip]
  (<span style=color:#66d9ef>let </span>[content (-&gt; (str <span style=color:#e6db74>&#34;http://api.openweathermap.org/data/2.5/find?q=&#34;</span>
                         zip
                         <span style=color:#e6db74>&#34;,USA&amp;units=imperial&#34;</span>)
                    client/get
                    <span style=color:#e6db74>:body</span>
                    json/read-str)]
    content))</code></pre></div><p>Our data of interest is laid out in objects inside objects. e.g.</p><pre><code>name       -&gt; list[0].name
temp       -&gt; list[0].main.temp
humidity   -&gt; list[0].main.humidity
temp-min   -&gt; list[0].main.temp_min
temp-max   -&gt; list[0].main.temp_max
conditions -&gt; list[0].weather[0].main
</code></pre><p>Although we can manually pull these values out, let&rsquo;s go a step further and brew up a function that does it for us.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>pull-values [m val-map]
  (into {} (for [[k v] val-map]
             [k (<span style=color:#a6e22e>get-in</span> m (<span style=color:#66d9ef>if </span>(<span style=color:#a6e22e>sequential?</span> v) v [v]))])))</code></pre></div><p>This function takes a map <code>m</code> to pull values out of and another map <code>val-map</code> which tells it which values to pull and what to assign them to.</p><p>We can use this function to pull our items of interest out of the OpenWeatherMap data.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>weather-for-zip [zip]
  (-&gt; (str <span style=color:#e6db74>&#34;http://api.openweathermap.org/data/2.5/find?q=&#34;</span>
           zip
           <span style=color:#e6db74>&#34;,USA&amp;units=imperial&#34;</span>)
      client/get
      <span style=color:#e6db74>:body</span>
      json/read-str
      (<span style=color:#a6e22e>pull-values</span> {<span style=color:#e6db74>:name</span> [<span style=color:#e6db74>&#34;list&#34;</span> <span style=color:#ae81ff>0</span> <span style=color:#e6db74>&#34;name&#34;</span>]
                    <span style=color:#e6db74>:temp</span> [<span style=color:#e6db74>&#34;list&#34;</span> <span style=color:#ae81ff>0</span> <span style=color:#e6db74>&#34;main&#34;</span> <span style=color:#e6db74>&#34;temp&#34;</span>]
                    <span style=color:#e6db74>:humidity</span> [<span style=color:#e6db74>&#34;list&#34;</span> <span style=color:#ae81ff>0</span> <span style=color:#e6db74>&#34;main&#34;</span> <span style=color:#e6db74>&#34;humidity&#34;</span>]
                    <span style=color:#e6db74>:temp-min</span> [<span style=color:#e6db74>&#34;list&#34;</span> <span style=color:#ae81ff>0</span> <span style=color:#e6db74>&#34;main&#34;</span> <span style=color:#e6db74>&#34;temp_min&#34;</span>]
                    <span style=color:#e6db74>:temp-max</span> [<span style=color:#e6db74>&#34;list&#34;</span> <span style=color:#ae81ff>0</span> <span style=color:#e6db74>&#34;main&#34;</span> <span style=color:#e6db74>&#34;temp_max&#34;</span>]
                    <span style=color:#e6db74>:conditions</span> [<span style=color:#e6db74>&#34;list&#34;</span> <span style=color:#ae81ff>0</span> <span style=color:#e6db74>&#34;weather&#34;</span> <span style=color:#ae81ff>0</span> <span style=color:#e6db74>&#34;main&#34;</span>]})))</code></pre></div><p>We&rsquo;ve gotten rid of the <code>content</code> def along with adding the <code>pull-value</code> call. Try this out in REPL (<code>cpp</code> and <code>cqc</code> in fireplace) and see if we&rsquo;re getting awesome results. Feel free to pull out more information like wind speed, direction etc.</p><h3 id=formatting-results>Formatting Results<a hidden class=anchor aria-hidden=true href=#formatting-results>#</a></h3><p>We now need to convert this hash-map of weather data into a nicer looking string representation. Let&rsquo;s write a function which does that:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>weather-to-str [w]
  (str (<span style=color:#e6db74>:name</span> w) <span style=color:#e6db74>&#34; &#34;</span> (<span style=color:#e6db74>:temp</span> w) <span style=color:#e6db74>&#34;F &#34;</span> (<span style=color:#e6db74>:conditions</span> w)
       <span style=color:#e6db74>&#34;, Min: &#34;</span> (<span style=color:#e6db74>:temp-min</span> w) <span style=color:#e6db74>&#34;F, Max: &#34;</span> (<span style=color:#e6db74>:temp-max</span> w) <span style=color:#e6db74>&#34;F&#34;</span>
       <span style=color:#e6db74>&#34;, Humidity: &#34;</span> (<span style=color:#e6db74>:humidity</span> w))</code></pre></div><p>This should give you a reasonable-looking weather string.</p><h3 id=putting-things-together>Putting things together<a hidden class=anchor aria-hidden=true href=#putting-things-together>#</a></h3><p>At this point we have all the pieces to post weather information to slack.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>weather-to-slack [zip]
  (<span style=color:#66d9ef>let </span>[weather (-&gt; zip
                    weather-for-zip
                    weather-to-str)]
    (<span style=color:#a6e22e>post-to-slack</span> hook-url {<span style=color:#e6db74>:text</span> weather
                             <span style=color:#e6db74>:icon_emoji</span> <span style=color:#e6db74>&#34;☁️&#34;</span>})))</code></pre></div><p>This function puts all the pieces together, taking a zip code and pushing the relevant weather information to the <code>hook-url</code> Slack URL.</p><h3 id=accepting-commands>Accepting Commands<a hidden class=anchor aria-hidden=true href=#accepting-commands>#</a></h3><p>So far we&rsquo;ve just been playing with the REPL, building our functions to fetch weather information and pushing it to Slack. We did start the project using a Compojure template, but we haven&rsquo;t used any web server functionality.</p><p>Slack Commands work by pushing information to a URL you provide. Try creating a Slack Command integration and it will give you details about what parameters Slack is going to send to you. Basically, whenever you type in <code>/command-name</code> in one of the channels, the Slack command gets triggered.</p><p>Your request handler is then supposed to return a string representing the result of the command. I like to send a progress message back, something like &ldquo;Please wait&mldr;&rdquo; and then do an actual post to the channel (using all of the stuff we&rsquo;ve already built) when I have the data available (weather information in our case).</p><p>Slack also sends you a token, which you should validate before accepting and processing a request.</p><p>At this time, I would open another terminal window, navigate to my project directory and run the ring server.</p><pre><code>lein ring server
</code></pre><p>This will serve the web service on port 3000 by default and will auto-update itself every time you modify the project source files.</p><p>Let&rsquo;s first set the basic Compojure handler to accept incoming commands. My <code>defroutes</code> definition now looks like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>defroutes</span> app-routes
  (<span style=color:#a6e22e>POST</span> <span style=color:#e6db74>&#34;/slack&#34;</span> request
        {<span style=color:#e6db74>:status</span> <span style=color:#ae81ff>200</span>
         <span style=color:#e6db74>:content-type</span> <span style=color:#e6db74>&#34;text/plain&#34;</span>
         <span style=color:#e6db74>:body</span> <span style=color:#e6db74>&#34;Getting weather information, please wait.&#34;</span>})
  (<span style=color:#a6e22e>route/resources</span> <span style=color:#e6db74>&#34;/&#34;</span>)
  (<span style=color:#a6e22e>route/not-found</span> <span style=color:#e6db74>&#34;Not Found&#34;</span>))</code></pre></div><p>Now setup a Slack Command Integration which will give the token information. When setting up the integration, Slack is going to ask you for the URL where it should post the command information. Since we&rsquo;re developing our stuff locally and don&rsquo;t really have a publicly accessible end-point, I usually run a tunneling software like <code>ngrok</code> to expose my services to the interwebs. <code>ngrok</code> will give you a URL where your service is reachable. Copy it and give it to Slack.</p><p>You should now be able to go to a channel and just type in <code>/weather</code>. You should see our response string popup.</p><p>The parameters will arrive under <code>(:params request)</code>. <code>:command</code> will contain the actual command (you can have multiple commands go to a single server). <code>:text</code> will contain any additional parameters sent to us .e.g the zip code. Let&rsquo;s do some error checking and see how things go.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>check-zip [zip]
  (re-matches <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;^\d{5}$&#34;</span> (<span style=color:#a6e22e>clojure.string/trim</span> zip)))

(<span style=color:#a6e22e>defroutes</span> app-routes
  (<span style=color:#a6e22e>POST</span> <span style=color:#e6db74>&#34;/slack&#34;</span> {<span style=color:#e6db74>:keys</span> [params] <span style=color:#e6db74>:as</span> request}
        (<span style=color:#66d9ef>if </span>(and (= <span style=color:#e6db74>&#34;/weather&#34;</span> (<span style=color:#e6db74>:command</span> params))
                 (= auth-token (<span style=color:#e6db74>:token</span> params))
                 (<span style=color:#a6e22e>check-zip</span> (<span style=color:#e6db74>:text</span> params)))
          {<span style=color:#e6db74>:status</span> <span style=color:#ae81ff>200</span>
           <span style=color:#e6db74>:content-type</span> <span style=color:#e6db74>&#34;text/plain&#34;</span>
           <span style=color:#e6db74>:body</span> <span style=color:#e6db74>&#34;Getting weather information, please wait.&#34;</span>}
          {<span style=color:#e6db74>:status</span> <span style=color:#ae81ff>400</span>
           <span style=color:#e6db74>:content-type</span> <span style=color:#e6db74>&#34;text/plain&#34;</span>
           <span style=color:#e6db74>:body</span> <span style=color:#e6db74>&#34;You need to provide a valid zip code&#34;</span>}))
  (<span style=color:#a6e22e>route/resources</span> <span style=color:#e6db74>&#34;/&#34;</span>)
  (<span style=color:#a6e22e>route/not-found</span> <span style=color:#e6db74>&#34;Not Found&#34;</span>))</code></pre></div><p>We first write a function <code>check-zip</code> which makes sure that provided zip codes are 5 digit numbers and spaces on either side of input are trimmed.</p><p>For the request to be valid, the <code>:command</code> field needs to say <code>"/command"</code>, the auth token needs to match the token we were given when we created the command integration and finally the zip code that arrived in <code>:text</code> needs to be valid. Play around with this either in your REPL or from the Slack channel window. I did reasonable amount of testing (2 mins) to make sure things were working.</p><p>Right now we just have the request returning a status message back to Slack. We&rsquo;re not really doing any actual work. We should now hook in our weather query machinery from before into this request handler, something like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>defroutes</span> app-routes
  (<span style=color:#a6e22e>POST</span> <span style=color:#e6db74>&#34;/slack&#34;</span> {<span style=color:#e6db74>:keys</span> [params] <span style=color:#e6db74>:as</span> request}
        (<span style=color:#66d9ef>if </span>(and (= <span style=color:#e6db74>&#34;/weather&#34;</span> (<span style=color:#e6db74>:command</span> params))
                 (= auth-token (<span style=color:#e6db74>:token</span> params))
                 (<span style=color:#a6e22e>check-zip</span> (<span style=color:#e6db74>:text</span> params)))
          (<span style=color:#a6e22e>do</span>
            (<span style=color:#a6e22e>thread</span> (<span style=color:#a6e22e>weather-to-slack</span> (<span style=color:#a6e22e>clojure.string/trim</span> (<span style=color:#e6db74>:text</span> params))))
            {<span style=color:#e6db74>:status</span> <span style=color:#ae81ff>200</span>
             <span style=color:#e6db74>:content-type</span> <span style=color:#e6db74>&#34;text/plain&#34;</span>
             <span style=color:#e6db74>:body</span> <span style=color:#e6db74>&#34;Getting weather information, please wait.&#34;</span>})
          {<span style=color:#e6db74>:status</span> <span style=color:#ae81ff>400</span>
           <span style=color:#e6db74>:content-type</span> <span style=color:#e6db74>&#34;text/plain&#34;</span>
           <span style=color:#e6db74>:body</span> <span style=color:#e6db74>&#34;You need to provide a valid zip code&#34;</span>}))
  (<span style=color:#a6e22e>route/resources</span> <span style=color:#e6db74>&#34;/&#34;</span>)
  (<span style=color:#a6e22e>route/not-found</span> <span style=color:#e6db74>&#34;Not Found&#34;</span>))</code></pre></div><p>Remember to refer to <code>thread</code> call by requiring <code>[clojure.core.async :refer [thread]]</code>. On a valid request we run our weather machinery in a separate thread, which eventually gets the data and posts it to the configured channel.</p><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>Hopefully it was a fun ride getting this to work. Some of the things referred to in this post:</p><ul><li><a href=https://slack.com/>Slack</a></li><li><a href=http://clojure.org/>Clojure</a></li><li><a href=https://github.com/weavejester/compojure>Compojure</a></li><li><a href=http://openweathermap.org/>OpenWeatherMap</a></li><li><a href=https://github.com/tpope/vim-fireplace>vim-fireplace</a></li><li><a href=https://ngrok.com/>ngrok</a></li></ul><p>If you&rsquo;re feeling particularly generous today, follow me on <a href=https://twitter.com/udaykverma>Twitter</a>.</p><h3 id=credits>Credits<a hidden class=anchor aria-hidden=true href=#credits>#</a></h3><p>Thanks to Liz Silich for proof-reading this post.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=http://udayv.com/>Uday Verma's Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>